#!/usr/bin/env node
import { Command } from 'commander';
import { compile } from 'json-schema-to-typescript';
import fs from 'fs/promises';
import path from 'path';
import { MCPOrchestrator } from '../orchestrator.js';
import { OrchestratorConfig } from '../types.js';

const program = new Command();

program
    .name('mcp-orchestrator-gen')
    .description('Generate TypeScript types from MCP servers')
    .requiredOption('-c, --config <path>', 'Path to MCP config file')
    .requiredOption('-o, --output <path>', 'Path to output TypeScript file')
    .parse(process.argv);

const options = program.opts();

async function main() {
    try {
        const configPath = path.resolve(process.cwd(), options.config);
        const configContent = await fs.readFile(configPath, 'utf-8');
        const config: OrchestratorConfig = JSON.parse(configContent);

        // Initialize orchestrator without autoConnect to control the flow
        const orchestrator = new MCPOrchestrator({
            ...config,
            connectionOptions: { autoConnect: false }
        });

        console.log('Connecting to MCP servers...');
        await orchestrator.connect();

        const tools = orchestrator.tools.list();
        console.log(`Found ${tools.length} tools.`);

        const interfaces: string[] = [];
        const toolMethodSignatures: string[] = [];

        for (const tool of tools) {
            const pascalCaseName = toPascalCase(tool.name);
            const inputInterfaceName = `${pascalCaseName}Input`;
            const outputInterfaceName = `${pascalCaseName}Output`;

            // Generate Input Schema
            if (tool.inputSchema) {
                const inputTs = await compile(tool.inputSchema as any, inputInterfaceName, {
                    bannerComment: '',
                    additionalProperties: false
                });
                interfaces.push(inputTs);
            } else {
                interfaces.push(`export interface ${inputInterfaceName} {}`);
            }

            // Generate Output Schema (assuming tool definition has outputSchema, 
            // though standard MCP tool list might not always provide it fully if dynamic. 
            // If not present, we use any or generic)
            // The PRD implies outputSchema is available. 
            // Standard MCP `Tool` type has `inputSchema`. Output schema is not strictly in the Tool definition in the spec 
            // (it's usually implicit or defined elsewhere), but for this exercise we'll assume it might be there 
            // or we just default to `any` for output if not provided.
            // Actually, the PRD example shows `tool.outputSchema`. 
            // If the SDK Tool type doesn't have it, we might need to extend it or check if it's in `...rest`.
            // For now, let's check if it exists, otherwise `any`.

            const outputSchema = (tool as any).outputSchema;
            if (outputSchema) {
                const outputTs = await compile(outputSchema, outputInterfaceName, {
                    bannerComment: '',
                    additionalProperties: false
                });
                interfaces.push(outputTs);
            } else {
                interfaces.push(`export type ${outputInterfaceName} = any;`);
            }

            toolMethodSignatures.push(
                `    callTool(name: '${tool.name}', args: ${inputInterfaceName}): Promise<${outputInterfaceName}>;`
            );
        }

        const outputContent = `
/* eslint-disable */
/**
 * This file was automatically generated by mcp-orchestrator.
 * DO NOT MODIFY IT BY HAND.
 */

import { MCPOrchestrator } from 'mcp-orchestrator';

${interfaces.join('\n')}

declare module 'mcp-orchestrator' {
  interface MCPOrchestrator {
${toolMethodSignatures.join('\n')}
  }
}
`;

        await fs.writeFile(path.resolve(process.cwd(), options.output), outputContent);
        console.log(`Generated types at ${options.output}`);

        await orchestrator.disconnect();
        process.exit(0);

    } catch (error) {
        console.error('Error generating types:', error);
        process.exit(1);
    }
}

function toPascalCase(str: string): string {
    return str
        .replace(/(?:^\w|[A-Z]|\b\w)/g, (word, index) =>
            index === 0 ? word.toUpperCase() : word.toUpperCase()
        )
        .replace(/\s+/g, '')
        .replace(/_/g, '');
}

main();
